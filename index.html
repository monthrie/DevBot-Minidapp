<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MiniDevBot</title>
    <script type="text/javascript" src="mds.js"></script>
    <link rel="icon" type="image/png" href="brain.png" />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css"
      rel="stylesheet"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <style>
      :root {
        --background: #0f172a;
        --foreground: #e2e8f0;
        --primary: #3b82f6;
        --secondary: #64748b;
        --accent: #f59e0b;
        --success: #10b981;
        --error: #ef4444;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        background-color: var(--background);
        color: var(--foreground);
        line-height: 1.6;
        display: flex;
        flex-direction: column;
        height: 100vh;
        overflow: hidden;
      }

      .title-banner {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        padding: 10px 20px;
        background: linear-gradient(to bottom, rgba(15, 23, 42, 0.8) 0%, rgba(15, 23, 42, 0) 100%);
        text-align: center;
        z-index: 1000;
        pointer-events: none;
      }

      .title {
        font-size: 1.2rem;
        font-weight: 700;
        color: var(--primary);
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin: 0;
        opacity: 0.8;
      }

      .chat-container {
        display: flex;
        flex-direction: column-reverse;
        flex-grow: 1;
        overflow-y: auto;
        padding: 80px 20px 20px;
        scroll-behavior: smooth;
        padding-top: 60px;
      }

      .chat-message {
        background-color: rgba(100, 116, 139, 0.1);
        padding: 12px 16px;
        border-radius: 12px;
        margin: 10px 0;
        max-width: 80%;
        line-height: 1.5;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
      }

      .chat-message:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .chat-message.user {
        background-color: rgba(59, 130, 246, 0.1);
        color: var(--foreground);
        align-self: flex-end;
        margin-left: auto;
      }

      .chat-message.bot {
        background-color: rgba(100, 116, 139, 0.1);
        color: var(--foreground);
        align-self: flex-start;
      }

      .input-container {
        display: flex;
        flex-direction: column;
        padding: 20px;
        background-color: rgba(15, 23, 42, 0.8);
        backdrop-filter: blur(10px);
        border-top: 1px solid rgba(255, 255, 255, 0.1);
      }

      .input-row {
        display: flex;
        align-items: flex-start;
        gap: 10px;
        position: relative;
      }

      .chat-input {
        flex-grow: 1;
        padding: 12px 16px;
        border-radius: 24px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background-color: rgba(100, 116, 139, 0.1);
        color: var(--foreground);
        font-size: 1rem;
        resize: none;
        transition: all 0.3s ease;
        min-height: 48px;
        max-height: 33vh;
        overflow-y: auto;
      }

      .send-button {
        padding: 12px 24px;
        border: none;
        border-radius: 24px;
        background-color: var(--primary);
        color: #ffffff;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 600;
        transition: all 0.3s ease;
        width: 100px;
        height: 48px;
        flex-shrink: 0;
      }

      .send-button:hover {
        background-color: #2563eb;
        transform: translateY(-2px);
      }

      .loader {
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-top: 3px solid var(--primary);
        border-radius: 50%;
        width: 24px;
        height: 24px;
        animation: spin 1s linear infinite;
        display: none;
        margin-left: 10px;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      pre[class*="language-"] {
        margin: 16px 0;
        padding: 16px;
        overflow: auto;
        border-radius: 8px;
        background-color: #1e293b !important;
      }

      code[class*="language-"] {
        font-family: 'Fira Code', 'Courier New', Courier, monospace;
        font-size: 0.9rem;
      }

      .sources-toggle {
        color: var(--accent);
        cursor: pointer;
        font-size: 0.9rem;
        margin-top: 12px;
        display: inline-block;
        transition: all 0.3s ease;
      }

      .sources-toggle:hover {
        color: #fbbf24;
      }

      .sources-content {
        display: none;
        margin-top: 8px;
        font-size: 0.9rem;
        color: var(--secondary);
      }

      .arrow {
        display: inline-block;
        transition: transform 0.3s;
      }

      .arrow.down {
        transform: rotate(90deg);
      }

      .popup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: var(--background);
        padding: 24px;
        border-radius: 12px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
        z-index: 1000;
        width: 90%;
        max-width: 400px;
        display: none;
      }

      .popup input {
        display: block;
        width: 100%;
        padding: 12px;
        margin-bottom: 16px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background-color: rgba(100, 116, 139, 0.1);
        color: var(--foreground);
        font-size: 1rem;
      }

      .popup button {
        width: 100%;
        padding: 12px;
        border: none;
        border-radius: 8px;
        background-color: var(--primary);
        color: #ffffff;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 600;
        transition: all 0.3s ease;
      }

      .popup button:hover {
        background-color: #2563eb;
      }

      .edit-button, .history-button {
        padding: 8px 16px;
        background-color: var(--secondary);
        color: var(--foreground);
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 600;
        transition: all 0.3s ease;
      }

      .edit-button:hover, .history-button:hover {
        background-color: #475569;
      }

      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(5px);
      }

      .modal-content {
        background-color: var(--background);
        margin: 10% auto;
        padding: 24px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        width: 90%;
        max-width: 600px;
        border-radius: 12px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
      }

      .close {
        color: var(--secondary);
        float: right;
        font-size: 28px;
        font-weight: bold;
        transition: all 0.3s ease;
      }

      .close:hover,
      .close:focus {
        color: var(--primary);
        text-decoration: none;
        cursor: pointer;
      }

      .copy-button {
        position: absolute;
        top: 8px;
        right: 8px;
        padding: 4px 8px;
        background-color: var(--primary);
        color: #ffffff;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.8rem;
        font-weight: 600;
        transition: all 0.3s ease;
      }

      .copy-button:hover {
        background-color: #2563eb;
      }

      .code-container {
        position: relative;
      }

      .custom-placeholder {
        position: absolute;
        top: 12px;
        left: 16px;
        color: var(--secondary);
        pointer-events: none;
        font-size: 1rem;
        transition: all 0.3s ease;
      }

      .strikethrough {
        text-decoration: line-through;
      }

      .chat-input:focus + .custom-placeholder,
      .chat-input:not(:placeholder-shown) + .custom-placeholder {
        transform: translateY(-24px) scale(0.8);
        color: var(--primary);
      }

      .loading-message {
        font-family: 'Fira Code', 'Courier New', Courier, monospace;
        color: var(--accent);
        font-size: 0.9rem;
        margin-bottom: 12px;
        display: none;
      }

      .about-button {
        padding: 8px 16px;
        background-color: var(--secondary);
        color: var(--foreground);
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 600;
        transition: all 0.3s ease;
        position: absolute;
        top: 10px;
        right: 20px;
        pointer-events: auto;
      }

      .about-button:hover {
        background-color: #475569;
      }

      @media (max-width: 768px) {
        .chat-message {
          max-width: 90%;
        }

        .title {
          font-size: 1.2rem;
        }

        .edit-button, .history-button {
          padding: 6px 12px;
          font-size: 0.8rem;
        }
      }

      .modal-content {
        font-family: Arial, sans-serif;
        line-height: 1.6;
        padding: 2rem;
        max-width: 600px;
        margin: 10% auto;
        width: 90%;
      }

      .modal-content h2 {
        margin-bottom: 1rem;
      }

      .modal-content h3 {
        margin-top: 1.5rem;
        margin-bottom: 0.5rem;
      }

      .modal-content ul {
        padding-left: 1.5rem;
      }

      .modal-content li {
        margin-bottom: 0.5rem;
      }

      @media (max-width: 768px) {
        .modal-content {
          width: 90%;
          padding: 1.5rem;
        }
      }

      .compile-button {
        position: absolute;
        top: 8px;
        right: 70px; /* Adjust based on the width of your copy button */
        padding: 4px 8px;
        background-color: var(--secondary);
        color: #ffffff;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.8rem;
        font-weight: 600;
        transition: all 0.3s ease;
      }

      .compile-button:hover {
        background-color: #475569;
      }

      .download-link {
        display: inline-block;
        margin-top: 10px;
        padding: 8px 16px;
        background-color: var(--success);
        color: #ffffff;
        text-decoration: none;
        border-radius: 4px;
        font-size: 0.9rem;
        font-weight: 600;
        transition: all 0.3s ease;
      }

      .download-link:hover {
        background-color: #059669;
      }
    </style>
</head>
<body>
    <div class="title-banner">
      <h1 class="title">DevBot v0.1.1 [MINIMA]</h1>
      <button class="about-button" onclick="showAbout()">About</button>
    </div>
    <div class="chat-container" id="chat-body">
      <!-- Messages will be inserted here by JavaScript -->
    </div>
    <div class="input-container">
      <div class="loading-message" id="loading-message">Thinking... may take up to 20 seconds...</div>
      <div class="input-row">
        <textarea
          class="chat-input"
          id="chat-input"
          rows="1"
        ></textarea>
        <button class="send-button" onclick="sendMessage()">Send</button>
        <div class="custom-placeholder" id="custom-placeholder">
          Type your question here... [cost is <span class="strikethrough">M</span>5]
        </div>
      </div>
    </div>

    <div id="info-modal" class="modal">
      <div class="modal-content">
        <span class="close">&times;</span>
        <h2>Welcome to MiniDevBot</h2>
        <p>MiniDevBot is your AI-powered development assistant on the Minima blockchain.</p>
        <h3>How it works:</h3>
        <ul>
          <li>Each question costs 5 Minima, automatically deducted from your wallet.</li>
          <li>To ask a question, simply type and hit send - payment is handled automatically.</li>
          <li>If you find a response particularly helpful, you can tip additional Minima.</li>
        </ul>
        <h3>Tips for best results:</h3>
        <ul>
          <li>Be specific in your questions for more accurate answers.</li>
          <li>Use code snippets when discussing specific code issues.</li>
          <li>Mark follow-up questions to maintain context in the conversation.</li>
        </ul>
        <p>Happy coding with MiniDevBot!</p>
      </div>
    </div>

    <script type="text/plain" id="mdsJsContent">

        /**
* MDS JS lib for MiniDAPPs..
* 
* @spartacusrex
*/

/**
 * The MAIN Minima Callback function 
 */
var MDS_MAIN_CALLBACK = null;

/**
 * API call id array
 */
var API_CALLS = [];

/**
 * Main MINIMA Object for all interaction
 */
var MDS = {
	
	//Main File host
	filehost : "",
	
	//RPC Host for Minima
	mainhost : "",
	
	//The MiniDAPP UID
	minidappuid : "",
	
	//Is logging RPC enabled
	logging : false,
	
	//When debuggin you can hard set the Host and port
	DEBUG_HOST : null,
	DEBUG_PORT : -1,
	
	//An allowed TEST Minidapp ID for SQL - can be overridden
	DEBUG_MINIDAPPID : "0x00",
	
	/**
	 * Minima Startup - with the callback function used for all Minima messages
	 */
	init : function(callback){
		//Log a little..
		MDS.log("Initialising MDS..");
		
		//Is logging enabled.. via the URL
		if(MDS.form.getParams("MDS_LOGGING") != null){
			MDS.logging = true;
		}
		
		//Get the host and port..
		var host = window.location.hostname;
		var port =  Math.floor(window.location.port);
		
		//Get ther MiniDAPP UID
		MDS.minidappuid = MDS.form.getParams("uid");
		
		//HARD SET if debug mode - running from a file
		if(MDS.DEBUG_HOST != null){
			MDS.log("DEBUG Settings Found..");
		
			host=MDS.DEBUG_HOST;
			port=MDS.DEBUG_PORT;	
		}
		
		if(MDS.minidappuid == null){
			MDS.minidappuid = MDS.DEBUG_MINIDAPPID;
		}
		
		//Is one specified..
		if(MDS.minidappuid == "0x00"){
			MDS.log("No MiniDAPP UID specified.. using test value");
		}
		
		MDS.filehost = "https://"+host+":"+port+"/";
		MDS.mainhost = "https://"+host+":"+port+"/mdscommand_/";
		MDS.log("MDS HOST  : "+MDS.filehost);
		
		//Store this for poll messages
		MDS_MAIN_CALLBACK = callback;
		
		//Start the Long Poll listener
		PollListener();
		
		//And Post a message
		MDSPostMessage({ "event": "inited" });
	},
	
	/**
	 * Log some data with a timestamp in a consistent manner to the console
	 */
	log : function(output){
		console.log("Minima @ "+new Date().toLocaleString()+" : "+output);
	},
	
	/**
	 * Notify the User - on Phone it pops up in status bar. On desktop appears in Logs
	 */
	notify : function(output){
		//Send via POST
		httpPostAsync("notify", output);
	},
	
	/**
	 * Cancel this MiniDAPPs notification
	 */
	notifycancel : function(){
		//Send via POST
		httpPostAsync("notifycancel", "*");
	},
	
	/**
	 * Runs a function on the Minima Command Line - same format as MInima
	 */
	cmd : function(command, callback){
		//Send via POST
		httpPostAsync("cmd", command, callback);
	},
	
	/**
	 * Runs a SQL command on this MiniDAPPs SQL Database
	 */
	sql : function(command, callback){
		//Send via POST
		httpPostAsync("sql", command, callback);
	},
	
	/**
	 * Get a link to a different Dapp. READ dapps can only get READ DAPPS. WRITE can get all dapps.
	 */
	dapplink : function(dappname, callback){
		//Send via POST
		httpPostAsync("dapplink", dappname, function(result){
			
			var linkdata 	= {};
			linkdata.status = result.status;
			 
			//Create the link..
			if(result.status){
				linkdata.uid 		= result.response.uid;
				linkdata.sessionid 	= result.response.sessionid;
				linkdata.base 		= MDS.filehost+linkdata.uid+"/index.html?uid="+result.response.sessionid;
			}else{
				//Not found..
				linkdata.error = result.error;
			}
			
			callback(linkdata);
		});
	},
	
	/**
	 * API call to a different minidapp
	 */
	api : {
		
		call : function(dappname, data, callback){
		
			//Construct a unique API request
			var rand = ""+Math.random()*1000000000;
			
			//Construct a callback list object
			var callitem 		= {};
			callitem.id 		= rand;
			callitem.callback 	= callback;
			
			//Add to the api calls..
			API_CALLS.push(callitem);
			
			//Create the single line
			var commsline = dappname+"&request&"+rand+"&"+data;		
			
			//Send via POST
			httpPostAsync("api", commsline);
		},
		
		reply : function(dappname, id, data, callback){
			
			//Create the single line
			var commsline = dappname+"&response&"+id+"&"+data;		
			
			//Send via POST
			httpPostAsync("api", commsline, callback);
		} 	
	},
	
	/**	
	 * Network Commands
	 */
	net : {
		
		/**
		 * Make a GET request
		 */
		GET : function(url, callback){
			//Send via POST
			httpPostAsync("net", url, callback);	
		},
		
		/**
		 * Make a POST request
		 */
		POST : function(url, data, callback){
			
			//Create the sinlg eline version..
			var postline = url+"&"+data;
			
			//Send via POST
			httpPostAsync("netpost", postline, callback);	
		}
		
	},
	
	/**	
	 *  Simple GET and SET key value pairs that are saved persistently
	 */
	keypair : {
		
		/**
		 * GET a value
		 */
		get : function(key, callback){
			
			//Create the single line
			var commsline = "get&"+key;		
			
			//Send via POST
			httpPostAsync("keypair", commsline, callback);	
		},
		
		/**
		 * SET a value
		 */
		set : function(key, value, callback){
			
			//Create the single line
			var commsline = "set&"+key+"&"+value;		
			
			//Send via POST
			httpPostAsync("keypair", commsline, callback);	
		}
	},
	
	/**	
	 * COMMS - send a message to ALL minidapps or JUST your own service.js
	 */
	comms : {
		
		/**
		 * PUBLIC message broadcast to ALL (callback is optional)
		 */
		broadcast : function(msg, callback){
			
			//Create the single line
			var commsline = "public&"+msg;		
			
			//Send via POST
			httpPostAsync("comms", commsline, callback);	
		},
		
		/**
		 * PRIVATE message send just to this MiniDAPP (callback is optional)
		 */
		solo : function(msg, callback){
			
			//Create the single line
			var commsline = "private&"+msg;		
			
			//Send via POST
			httpPostAsync("comms", commsline, callback);	
		}
		
	},
	
	/**
	 * File access
	 */
	file : {
		/**
		 * List file in a folder .. start at /
		 */
		list : function(folder, callback){
			
			//Create the single line
			var commsline = "list&"+folder;		
			
			//Send via POST
			httpPostAsync("file", commsline, callback);
		},
		
		/**
		 * Save text - can be text, a JSON in string format or hex encoded data
		 */
		save : function(filename, text, callback){
			
			//Create the single line
			var commsline = "save&"+filename+"&"+text;		
			
			//Send via POST
			httpPostAsync("file", commsline, callback);
		},
		
		/**
		 * Save Binary Data - supply as a HEX string
		 */
		savebinary : function(filename, hexdata, callback){
			
			//Create the single line
			var commsline = "savebinary&"+filename+"&"+hexdata;		
			
			//Send via POST
			httpPostAsync("file", commsline, callback);
		},
		
		/**
		 * Load text - can be text, a JSON in string format or hex encoded data
		 */
		load : function(filename, callback){
			
			//Create the single line
			var commsline = "load&"+filename;		
			
			//Send via POST
			httpPostAsync("file", commsline, callback);
		},
		
		/**
		 * Load Binary data - returns the HEX data
		 */
		loadbinary : function(filename, callback){
			
			//Create the single line
			var commsline = "loadbinary&"+filename;		
			
			//Send via POST
			httpPostAsync("file", commsline, callback);
		},
		
		/**
		 * Delete a file
		 */
		delete : function(filename, callback){
			
			//Create the single line
			var commsline = "delete&"+filename;		
			
			//Send via POST
			httpPostAsync("file", commsline, callback);
		},
		
		/**
		 * Get the full path - if you want to run a command on the file / import a txn / unsigned txn etc
		 */
		getpath : function(filename, callback){
			
			//Create the single line
			var commsline = "getpath&"+filename;		
			
			//Send via POST
			httpPostAsync("file", commsline, callback);
		},
		
		/**
		 * Make a directory
		 */
		makedir : function(filename, callback){
			
			//Create the single line
			var commsline = "makedir&"+filename;		
			
			//Send via POST
			httpPostAsync("file", commsline, callback);
		},
		
		/**
		 * Copy a file
		 */
		copy : function(filename, newfilename, callback){
			
			//Create the single line
			var commsline = "copy&"+filename+"&"+newfilename;		
			
			//Send via POST
			httpPostAsync("file", commsline, callback);
		},
		
		/**
		 * Move a file
		 */
		move : function(filename, newfilename, callback){
			
			//Create the single line
			var commsline = "move&"+filename+"&"+newfilename;		
			
			//Send via POST
			httpPostAsync("file", commsline, callback);
		},
		
		/**
		 * Download a File from the InterWeb - Will be put in Downloads folder
		 */
		download : function(url, callback){
			
			//Create the single line
			var commsline = "download&"+url;
			
			//Send via POST
			httpPostAsync("file", commsline, callback);	
		},
		
		/**
		 * Upload a file in chunks to the /fileupload folder		
		 */
		upload : function(file, callback){
			
			//Start the file recursion..
			_recurseUploadMDS(file,0,callback);
		},
		
		/**
		 * List file in a folder .. start at /
		 */
		listweb : function(folder, callback){
			
			//Create the single line
			var commsline = "listweb&"+folder;		
			
			//Send via POST
			httpPostAsync("file", commsline, callback);
		},
		
		/**
		 * Copy a file to your web folder
		 */
		copytoweb : function(file, webfile, callback){
			
			//Create the single line
			var commsline = "copytoweb&"+file+"&"+webfile;
			
			//Send via POST
			httpPostAsync("file", commsline, callback);	
		},
		
		/**
		 * Delete a file or folder from web folder
		 */
		deletefromweb : function(file, callback){
			
			//Create the single line
			var commsline = "deletefromweb&"+file;
			
			//Send via POST
			httpPostAsync("file", commsline, callback);	
		}
		
	}, 
	
	/**
	 * Function for GET parameters..
	 */
	form : {
		
		//Return the GET parameter by scraping the location..
		getParams : function(parameterName){
			    var result = null,
		        tmp = [];
			    var items = window.location.search.substr(1).split("&");
			    for (var index = 0; index < items.length; index++) {
			        tmp = items[index].split("=");
			        //console.log("TMP:"+tmp);
				   if (tmp[0] === parameterName) result = decodeURIComponent(tmp[1]);
			    }
			    return result;
		}		
	},
	
	/**
	 * UTILITY functions.. very useful
	 */
	util : {
		
		//Convert HEX to Base 64 - removes the 0x if necessary
		hexToBase64(hexstring) {
			//Check if starts with 0x
			var thex = hexstring;
			if(hexstring.startsWith("0x")){
				thex = hexstring.substring(2);
			}	
			
		    return btoa(thex.match(/\w{2}/g).map(function(a) {
		        return String.fromCharCode(parseInt(a, 16));
		    }).join(""));
		},
	
		//Convert Base64 to HEX	
		base64ToHex(str) {
			const raw = atob(str);
			let result = '';
			for (let i = 0; i < raw.length; i++) {
				const hex = raw.charCodeAt(i).toString(16);
				result += (hex.length === 2 ? hex : '0' + hex);
			}
			return result.toUpperCase();
		},
		
		//Convert Base64 to a Uint8Array - useful for Blobs
		base64ToArrayBuffer(base64) {
		    var binary_string = window.atob(base64);
		    var len = binary_string.length;
		    var bytes = new Uint8Array(len);
		    for (var i = 0; i < len; i++) {
		        bytes[i] = binary_string.charCodeAt(i);
		    }
		    return bytes.buffer;
		},
		
		//Return a state variable given the coin
		getStateVariable(coin,port){
			
			//Get the state vars
			var statvars = coin.state;
			var len = statvars.length;
			for (var i = 0; i < len; i++) {
				var state = statvars[i];
				if(state.port == port){
					return state.data;
				} 	
			}
			
			return undefined;
		}
	}
};

/**
 * Post a message to the Minima Event Listeners
 */
function MDSPostMessage(json){
   //And dispatch
   if(MDS_MAIN_CALLBACK){
		
		//Is this an API response call..
		if(json.event == "MDSAPI"){
			
			//Check if it is a response..
			if(!json.data.request){
				
				//Find the API CALL Object
				var found = "";
				var len = API_CALLS.length;
				for(var i=0;i<len;i++){
					if(API_CALLS[i].id == json.data.id){
						//found it..!
						found = json.data.id;
						
						//Construct a reply..
						var reply 	 = {};
						reply.status = json.data.status; 
						reply.data 	 = json.data.message;
						
						API_CALLS[i].callback(reply);
					}
				}	
				
				//Remove it..
				if(found != ""){
					API_CALLS = API_CALLS.filter(function(apic){
						return apic.id != found; 
					});
				}else{
					//MDS.log("API CALL NOT FOUND!"+JSON.stringify(json));	
				}
				
				//Response messages not forwarded - only via API call
				return;	
			}
		}
		
		//Call the main function
		MDS_MAIN_CALLBACK(json);	
   }      
}


var PollCounter = 0;
var PollSeries  = 0;
function PollListener(){
	
	//The POLL host
	var pollhost = MDS.mainhost+"poll?"+"uid="+MDS.minidappuid;
	var polldata = "series="+PollSeries+"&counter="+PollCounter;
	
	httpPostAsyncPoll(pollhost,polldata,function(msg){
		
		//Are we on the right Series..
		if(PollSeries != msg.series){
			
			//Reset to the right series.. 
			PollSeries  = msg.series;
			PollCounter = msg.counter;
			
		}else{
			
			//Is there a message ?
			if(msg.status == true){
				
				//Get the current counter..
				PollCounter = msg.response.counter+1;
				
				//And Post the message..
				MDSPostMessage(msg.response.message);	
			}	
		}
		
		//And around we go again..
		PollListener();
	});
}

function postMDSFail(command, params, status){
	//Some error..
	if(MDS.logging){
		MDS.log("** An error occurred during an MDS command!");
	}
	
	//Create the message
	var errormsg = {};
	errormsg.event = "MDSFAIL";
	errormsg.data = {};
	errormsg.data.command 	= command;
	errormsg.data.params 	= params;
	errormsg.data.error 	= status;
				
	//Post it to the stack			
	MDSPostMessage(errormsg);
}

/**
 * Utility function for GET request
 * 
 * @param theUrl
 * @param callback
 * @param params
 * @returns
 */
function httpPostAsync(theUrl, params, callback){
	
	//Add the MiniDAPP UID..
	var finalurl = MDS.mainhost+theUrl+"?uid="+MDS.minidappuid;
	
	//Do we log it..
	if(MDS.logging){
		MDS.log("POST_RPC:"+finalurl+" PARAMS:"+params);
	}

	var xmlHttp = new XMLHttpRequest();
    xmlHttp.onreadystatechange = function() { 
        
		var status = xmlHttp.status;
		if (xmlHttp.readyState == XMLHttpRequest.DONE){
			if (status === 0 || (status >= 200 && status < 400)) {
			
				//Do we log it..
	        	if(MDS.logging){
	        		MDS.log("RESPONSE:"+xmlHttp.responseText);
	        	}
	
	        	//Send it to the callback function..
	        	if(callback){
	        		callback(JSON.parse(xmlHttp.responseText));
	        	}
	        
			}else{
				//Some error..
				postMDSFail(finalurl,params,xmlHttp.status);
			}
		}
    }
    xmlHttp.open("POST", finalurl, true); // true for asynchronous 
	xmlHttp.overrideMimeType('text/plain; charset=UTF-8');
    xmlHttp.send(encodeURIComponent(params));
	//xmlHttp.onerror = function () {
	//  console.log("** An error occurred during the transaction");
	//};
}

/**
 * POLLING Call
 */
function httpPostAsyncPoll(theUrl, params, callback){
	//Do we log it..
	if(MDS.logging){
		MDS.log("POST_POLL_RPC:"+theUrl+" PARAMS:"+params);
	}

	var xmlHttp = new XMLHttpRequest();
    xmlHttp.onreadystatechange = function() { 
        var status = xmlHttp.status;
		if (xmlHttp.readyState == XMLHttpRequest.DONE){
			if (status === 0 || (status >= 200 && status < 400)) {
			
				//Do we log it..
	        	if(MDS.logging){
	        		MDS.log("RESPONSE:"+xmlHttp.responseText);
	        	}
	
	        	//Send it to the callback function..
	        	if(callback){
	        		callback(JSON.parse(xmlHttp.responseText));
	        	}
	        
			}else{
				//Some error..
				postMDSFail(theUrl,params,xmlHttp.status);
			}
		}
    }
    xmlHttp.addEventListener('error', function(ev){
		MDS.log("Error Polling - reconnect in 10s");
		setTimeout(function(){PollListener();},10000);
	});
    xmlHttp.open("POST", theUrl, true); // true for asynchronous 
	xmlHttp.overrideMimeType('text/plain; charset=UTF-8');
    xmlHttp.send(encodeURIComponent(params));
}

/**
 * Internal recursive function for file upload 
 */
function _recurseUploadMDS(thefullfile, chunk, callback){
		
	//Get some details
	var filename 	= thefullfile.name;
	var filesize 	= thefullfile.size;
	
	//1MB MAX Chunk size..
	var chunk_size 	= 1024 * 1024;
	var allchunks  	= Math.ceil(filesize / chunk_size);
	
	//Have we finished..
	if(chunk>allchunks-1){
		return;
	}
	
	var startbyte = chunk_size * chunk;
	var endbyte   = startbyte + chunk_size;
	if(endbyte>filesize){
		endbyte = filesize;
	}
	
	//Get a piece of the file
	var filepiece = thefullfile.slice(startbyte,endbyte);
	
	//Create a form..
	var formdata = new FormData();
	formdata.append("uid", MDS.minidappuid);
	
	//Filedata handled a little differently
	formdata.append("filename", filename);
	formdata.append("filesize", filesize);
	formdata.append("allchunks", allchunks);
	formdata.append("chunknum", chunk);
	formdata.append("fileupload", filepiece);
  
	var request = new XMLHttpRequest();
	request.open("POST", "/fileuploadchunk.html");
	request.onreadystatechange = function() { 
	        
		var status = request.status;
		if (request.readyState == XMLHttpRequest.DONE){
			if (status === 0 || (status >= 200 && status < 400)) {
				
				//Send it to the callback function..
	        	if(callback){
	        		var resp 		= {};
	        		resp.status		= true;
	        		resp.filename 	= filename;
	        		resp.size 		= filesize;
	        		resp.allchunks 	= allchunks;
	        		resp.chunk 		= chunk+1;
	        		resp.start 		= startbyte;
	        		resp.end 		= endbyte;
	        		
	        		callback(resp);
	        	}
	        
				//And now continue uploading..
				if(callback){
					_recurseUploadMDS(thefullfile,chunk+1, callback);	
				}else{
					_recurseUploadMDS(thefullfile,chunk+1);
				}				
				
			}else{
				if(callback){
	        		var resp 		= {};
	        		resp.status		= false;
	        		resp.error		= request.responseText;
	        		resp.filename 	= filename;
	        		resp.size 		= filesize;
	        		resp.allchunks 	= allchunks;
	        		resp.chunk 		= chunk;
	        		resp.start 		= startbyte;
	        		resp.end 		= endbyte;
	        		
	        		callback(resp);
	        	}
					
				//Some error..
				MDS.log("MDS FILEUPLOAD CHUNK ERROR: "+request.responseText);
			}
		}
    }

	//And finally send the POST request
	request.send(formdata);
}

    </script>

    <script type="text/plain" id="dappConfContent">

        {
            "name": "AAA TEST",
            "icon": "brain.png",
            "version": "0.1.0",
            "description": "could be anything",
            "browser": "internal"
          }

    </script>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        const chatInput = document.getElementById("chat-input");
        const customPlaceholder = document.getElementById("custom-placeholder");

        chatInput.addEventListener("input", function () {
          if (chatInput.value) {
            customPlaceholder.style.display = "none";
          } else {
            customPlaceholder.style.display = "block";
          }
        });

        chatInput.addEventListener("focus", function () {
          customPlaceholder.style.display = "none";
        });

        chatInput.addEventListener("blur", function () {
          if (!chatInput.value) {
            customPlaceholder.style.display = "block";
          }
        });

        document.querySelector("#info-modal .close").addEventListener("click", function() {
          document.getElementById("info-modal").style.display = "none";
        });
      });

      // Initialize MDS
      MDS.init(function(msg) {
        if (msg.event === "inited") {
          console.log("MDS initialized");

          // Create the chatbot_responses table if it doesn't exist
          MDS.sql("CREATE TABLE IF NOT EXISTS chatbot_responses (id INT AUTO_INCREMENT PRIMARY KEY, timestamp DATETIME, response TEXT)", function(res) {
            if (res.status) {
              console.log("Table created successfully");
            } else {
              console.error("Error creating table:", res.error);
            }
          });
        }
      });

      function storeChatbotResponse(response) {
        const timestamp = new Date().toISOString();
        const jsonResponse = JSON.stringify(response);
        
        // Escape single quotes in the JSON string to prevent SQL injection
        const escapedJsonResponse = jsonResponse.replace(/'/g, "''");
        
        const sqlQuery = `INSERT INTO chatbot_responses (timestamp, response) VALUES ('${timestamp}', '${escapedJsonResponse}')`;
        
        MDS.sql(sqlQuery, function(res) {
          if (res.status) {
            console.log("Response stored successfully");
          } else {
            console.error("Error storing response:", res.error);
          }
        });
      }

      function getChatbotResponses(callback) {
        MDS.sql("SELECT * FROM chatbot_responses ORDER BY `timestamp` DESC", function(res) {
          if (res.status) {
            const responses = res.rows.map(row => ({
              id: row.id,
              timestamp: row.timestamp,
              response: JSON.parse(row.response)
            }));
            callback(responses);
          } else {
            console.error("Error retrieving responses:", res.error);
            callback([]);
          }
        });
      }

      async function sendMessage() {
        const inputElement = document.getElementById("chat-input");
        const message = inputElement.value;
        if (!message) return;

        displayMessage("user", message);
        inputElement.value = "";
        inputElement.style.height = "auto";

        document.getElementById("loading-message").style.display = "block";

        try {
          // Charge 5 Minima before sending the message
          const res = await new Promise((resolve) => {
            MDS.cmd(
              "send address:MxG081C1476BJCHSQFF7K7ACMR4G111JMPCYEED3E4TFB02NA3D4TF4KEVGWH32 amount:5",
              resolve
            );
          });

          if (!res.status) {
            alert("Payment failed. Please try again.");
            return;
          }

          const response = await fetch(
            "https://devbot-api-production.up.railway.app/chat",
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Access-Control-Allow-Origin": "*",
              },
              body: JSON.stringify({
                message: message,
              }),
            }
          );
          const data = await response.json();

          if (data.error) {
            throw new Error(data.error);
          }

          console.log("Response content:", data.answer);

          const codeBlocks = data.answer.match(/```[\s\S]*?```/g);
          if (codeBlocks) {
            console.log("Detected code blocks:");
            codeBlocks.forEach((block, index) => {
              console.log(`Code Block ${index + 1}:`);
              console.log(block);
            });
          }

          displayMessage("bot", data.answer, data.sources);

          // Store the response in the database
          storeChatbotResponse(data.answer);

        } catch (error) {
          console.error("Error:", error);
          displayMessage(
            "bot",
            "Sorry, something went wrong: " + error.message
          );
        } finally {
          document.getElementById("loading-message").style.display = "none";
        }
      }

      function escapeHtml(unsafe) {
        return unsafe
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      function copyToClipboard(text) {
        navigator.clipboard.writeText(text).then(
          function () {
            alert("Copied to clipboard!");
          },
          function (err) {
            console.error("Could not copy text: ", err);
          }
        );
      }

      function displayMessage(sender, message, sources = []) {
        const chatBody = document.getElementById("chat-body");
        const messageElement = document.createElement("div");
        messageElement.className = `chat-message ${sender}`;

        const parts = message.split(/(```[\s\S]*?```)/);

        parts.forEach((part, index) => {
          if (part.startsWith("```") && part.endsWith("```")) {
            const codeContent = part.slice(3, -3).trim();
            const firstLine = codeContent.split("\n")[0].trim();
            const language = firstLine.match(/^[a-zA-Z0-9]+$/)
              ? firstLine
              : "plaintext";
            const code =
              language === "plaintext"
                ? codeContent
                : codeContent.split("\n").slice(1).join("\n");

            const preElement = document.createElement("pre");
            preElement.className = `language-${language}`;

            const codeElement = document.createElement("code");
            codeElement.className = `language-${language}`;
            codeElement.textContent = code;

            const codeContainer = document.createElement("div");
            codeContainer.className = "code-container";

            const copyButton = document.createElement("button");
            copyButton.className = "copy-button";
            copyButton.textContent = "Copy";
            copyButton.onclick = function () {
              copyToClipboard(code);
            };

            const compileButton = document.createElement("button");
            compileButton.className = "compile-button";
            compileButton.textContent = "Compile MiniDapp";
            compileButton.onclick = function () {
              compileMiniDapp(code);
            };

            codeContainer.appendChild(copyButton);
            codeContainer.appendChild(compileButton);
            codeContainer.appendChild(preElement);
            preElement.appendChild(codeElement);
            messageElement.appendChild(codeContainer);
          } else {
            const paragraphs = part.split("\n\n");
            paragraphs.forEach((paragraph, pIndex) => {
              if (paragraph.trim()) {
                const p = document.createElement("p");
                p.style.margin =
                  pIndex === 0 && index === 0 ? "0 0 10px 0" : "10px 0";

                if (/^\d+\.\s/.test(paragraph)) {
                  p.style.marginLeft = "20px";
                }

                p.innerHTML = escapeHtml(paragraph).replace(/\n/g, "<br>");

                messageElement.appendChild(p);
              }
            });
          }
        });

        if (sources && sources.length > 0) {
          const sourcesToggle = document.createElement("div");
          sourcesToggle.className = "sources-toggle";
          sourcesToggle.innerHTML = '<span class="arrow">▶</span> Show sources';
          messageElement.appendChild(sourcesToggle);

          const sourcesContent = document.createElement("div");
          sourcesContent.className = "sources-content";
          sourcesContent.innerHTML = sources
            .map((source) => {
              const cleanedSource = source.replace(/^.*?(type|input)\//, '');
              return `- ${escapeHtml(cleanedSource)}`;
            })
            .join("<br>");
          messageElement.appendChild(sourcesContent);

          sourcesToggle.onclick = function () {
            const arrow = this.querySelector(".arrow");
            arrow.classList.toggle("down");
            if (
              sourcesContent.style.display === "none" ||
              sourcesContent.style.display === ""
            ) {
              sourcesContent.style.display = "block";
              this.innerHTML = '<span class="arrow down">▶</span> Hide sources';
            } else {
              sourcesContent.style.display = "none";
              this.innerHTML = '<span class="arrow">▶</span> Show sources';
            }
          };
        }

        chatBody.insertBefore(messageElement, chatBody.firstChild);

        Prism.highlightAllUnder(messageElement);
      }

      function adjustTextareaHeight() {
        const textarea = document.getElementById("chat-input");
        textarea.style.height = "auto";
        const newHeight = Math.min(textarea.scrollHeight, window.innerHeight / 3);
        textarea.style.height = newHeight + "px";
      }

      document
        .getElementById("chat-input")
        .addEventListener("input", adjustTextareaHeight);

      window.addEventListener("resize", adjustTextareaHeight);

      adjustTextareaHeight();

      function showAbout() {
        document.getElementById("info-modal").style.display = "block";
      }

      window.onclick = function(event) {
        if (event.target == document.getElementById("info-modal")) {
          document.getElementById("info-modal").style.display = "none";
        }
      }

      function compileMiniDapp(codeContent) {
        // Prompt the user for a MiniDapp name
        const dappName = prompt("Enter a name for your MiniDapp:", "MyMiniDapp_" + Date.now());
        
        if (!dappName) {
          alert("MiniDapp compilation cancelled.");
          return;
        }

        // Create a basic HTML structure with the code content
        const htmlContent = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${dappName}</title>
    <script type="text/javascript" src="mds.js"><\/script>
</head>
<body>
    <pre><code>${codeContent}</code></pre>
    <script>
        // Initialize MDS
        MDS.init(function(msg) {
            if (msg.event === "inited") {
                console.log("MDS initialized");
            }
        });
    <\/script>
</body>
</html>
`;

        // Update dapp.conf content with the new name
        const dappConfContent = {
          name: dappName,
          icon: "brain.png",
          version: "0.1.0",
          description: "Generated MiniDapp",
          browser: "internal"
        };

        createMiniDapp(htmlContent, dappConfContent, dappName);
      }

      function createMiniDapp(htmlContent, dappConfContent, dappName) {
        const zip = new JSZip();

        // Add index.html
        zip.file("index.html", htmlContent);

        // Add mds.js content
        const mdsJsContent = document.getElementById('mdsJsContent').textContent;
        zip.file("mds.js", mdsJsContent);

        // Add updated dapp.conf content
        zip.file("dapp.conf", JSON.stringify(dappConfContent, null, 2));

        // Generate and save zip
        generateAndSaveZip(zip, dappName);
      }

      function generateAndSaveZip(zip, dappName) {
        zip.generateAsync({type:"base64"})
        .then(function(content) {
          const fileName = `${dappName}.zip`;
          MDS.file.save(fileName, content, function(saveResp) {
            if (saveResp.status) {
              alert("MiniDapp created and saved as " + fileName);
              createDownloadLink(fileName);
            } else {
              alert("Error saving the MiniDapp: " + saveResp.error);
            }
          });
        });
      }

      // Update createDownloadLink function to use the custom dappName
      function createDownloadLink(fileName) {
        MDS.file.load(fileName, function(loadResp) {
          if (loadResp.status) {
            const base64Content = loadResp.response.load.data;
            const blob = base64ToBlob(base64Content, 'application/zip');
            const url = URL.createObjectURL(blob);
            
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.download = fileName;
            downloadLink.textContent = `Download ${fileName}`;
            downloadLink.className = 'download-link';
            
            // Append the download link to the chat body
            const chatBody = document.getElementById('chat-body');
            chatBody.insertBefore(downloadLink, chatBody.firstChild);
          } else {
            console.error("Error loading file for download: " + loadResp.error);
          }
        });
      }

      function base64ToBlob(base64, mimeType) {
        const byteCharacters = atob(base64);
        const byteArrays = [];

        for (let offset = 0; offset < byteCharacters.length; offset += 512) {
          const slice = byteCharacters.slice(offset, offset + 512);
          const byteNumbers = new Array(slice.length);
          for (let i = 0; i < slice.length; i++) {
            byteNumbers[i] = slice.charCodeAt(i);
          }
          const byteArray = new Uint8Array(byteNumbers);
          byteArrays.push(byteArray);
        }

        return new Blob(byteArrays, {type: mimeType});
      }
    </script>
</body>
</html>